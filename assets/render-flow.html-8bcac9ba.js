import{_ as a,a0 as e,a1 as n,a4 as r}from"./framework-786d5328.js";const p={},s=r(`<h1 id="浏览器渲染流程" tabindex="-1"><a class="header-anchor" href="#浏览器渲染流程" aria-hidden="true">#</a> 浏览器渲染流程</h1><p>打开浏览器，在浏览器的地址栏中输入一个URL，按下回车键，得到一个页面。在我们看来一切都是如此自然，但这其中发生的一系列事情，是非常复杂的。</p><p>整个过程大致可以分为两块内容：</p><ul><li>网络通信</li><li>浏览器渲染</li></ul><h2 id="网络通信" tabindex="-1"><a class="header-anchor" href="#网络通信" aria-hidden="true">#</a> 网络通信</h2><p>网络通信的作用是从服务器获取到资源，网络通信是一个极其复杂的过程，这个过程涉及到整个计算机网络，大致需要经过这些：</p><ol><li>缓存</li><li>TCP连接</li><li>获取资源文件</li></ol><h2 id="浏览器渲染" tabindex="-1"><a class="header-anchor" href="#浏览器渲染" aria-hidden="true">#</a> 浏览器渲染</h2><p>浏览器通过网络通信获取到服务器的资源文件后，将该资源文件加入到浏览器的消息队列中，经过浏览器的事件循环机制，该资源文件就到了浏览器的渲染主线程中，接下来就是浏览器解析该文件的过程。实际上浏览器得到的是字符串，它是如何将这一串字符串解析成如此精彩的页面的呢？</p><p>这就涉及到了浏览器的渲染机制，这同样也是一个非常复杂的过程，以上下就是浏览器渲染的主要过程，一共经历八个阶段，每一个阶段环环相扣，像是工厂的流水线一般，上一个阶段的输出成为下一个阶段的输入，直至完成页面的渲染。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/22090223/1677675559565-ccf66ec5-9d43-4de0-b8cf-6a26692fe147.jpeg" alt=""></p><p>下面就具体的说一下每一个阶段做了什么事。</p><h3 id="_1-解析html文件" tabindex="-1"><a class="header-anchor" href="#_1-解析html文件" aria-hidden="true">#</a> 1.解析HTML文件</h3><p><strong>渲染主线程从上到下解析HTML文件中的内容。</strong></p><p>遇到普通的标签解析成为DOM元素，并放到DOM树上。</p><p><code>&lt;link&gt;</code>标签被视为CSS资源。渲染主线程遇到该标签后不会停止HTML文件的解析，它会将该任务交给其它线程去处理，然后继续往下解析HTML文件中的内容。其它线程会通过网络线程将该资源文件下载下来，下载完毕后对该文件做进一步的处理，处理完毕后将它交还给渲染主线程。渲染主线程收到经过预处理后的CSS资源，将它们解析成CSSOM树。在解析的过程中遇到的<code>&lt;style&gt;</code>标签以及行内的样式也会被解析成CSSOM树。</p><p>渲染主线程在解析的过程中如果遇到了<code>&lt;script&gt;</code>标签会停止对HTML文档的解析，如果该标签中的内容需要下载，也会通过网络线程去下载该资源文件，并且开始执行该文件中的内容。至于为什么需要执行解析，而与CSS相关的资源不会暂停解析，是因为scrip标签中有可能涉及到对DOM的操作。</p><p>经过该过程后会得到DOM树和CSSOM树。</p><h3 id="_2-计算样式" tabindex="-1"><a class="header-anchor" href="#_2-计算样式" aria-hidden="true">#</a> 2.计算样式</h3><p>在这个阶段，DOM树和CSSOM树中的DOM节点和CSS样式会相应的结合，并完成最终样式的计算，生成一颗带有样式的DOM树。</p><p>经过该过程后会得到一个带有样式的DOM树</p><h3 id="_3-生成布局树" tabindex="-1"><a class="header-anchor" href="#_3-生成布局树" aria-hidden="true">#</a> 3.生成布局树</h3><p><strong>在这个阶段，会根据带有样式的DOM树，遍历树上的每一个节点，完成布局的过程，生成一颗布局树</strong>。主要的操作是：</p><ul><li>计算每个节点的集合信息（宽、高、包含块的信息）</li><li>把相对单位转换成绝对单位（我的理解是把我们可以理解的单位转换成浏览器可以认识的单位）</li><li>在需要的地方生成匿名行盒或者匿名块盒</li><li>加入伪元素（如before、after等）</li><li>将带有display:none的节点元素从布局树上删除</li></ul><p>经过该过程后会得到一个布局树，也就是Layout树</p><h3 id="_4-分层" tabindex="-1"><a class="header-anchor" href="#_4-分层" aria-hidden="true">#</a> 4.分层</h3><p><strong>在这个阶段，浏览器会根据布局树生成以及自己复杂的策略，进行分层处理。将布局树上的内容分布在不同的层面上。</strong></p><p>为什么要分层？分层的好处是什么？</p><p>分层的好处是性能上的提升。假设不进行分层处理，所有的元素信息都在同一层上，那么某一个元素发生改变的时候，会影响到该页面的所有其它元素。如果进行一个分层的处理，那么只能影响到该层中的内容。</p><p>最常见的分层就是侧边的滚动条。在下拉页面的时候，这个滚动条是无时无刻的都会发生变化的，不进行分层处理结果可想而知。</p><p>分层的行为是浏览器根据自己的策略进行的，也可以通过CSS样式告诉浏览器，这个元素将来可能会发生变动，进行分层。</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">div</span><span class="token punctuation">{</span>
  <span class="token property">will-change</span><span class="token punctuation">:</span> contents<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该过程结束后会得到不同层级以及每个层级上不同的信息。</p><h3 id="_5-绘制指令" tabindex="-1"><a class="header-anchor" href="#_5-绘制指令" aria-hidden="true">#</a> 5.绘制指令</h3><p><strong>在这个阶段，会根据每一层中的信息来生成绘制指令集。</strong></p><p>什么是绘制指令集？就是许许多多绘制指令的集合</p><p>什么是绘制指令？绘制指令详细的告诉浏览器在哪一个位置，需要从哪里开始，画一个多大的元素，这个元素的颜色是什么、边框是怎么样的...</p><p>该过程结束后每一层中都会有绘制指令集</p><h3 id="_6-分块" tabindex="-1"><a class="header-anchor" href="#_6-分块" aria-hidden="true">#</a> 6.分块</h3><p><strong>该过成将每一层中的区域划分成多块。</strong></p><p>在这个过程中，渲染主线程将每个图层中的信息交给合成线程处理。至此浏览器的渲染主线程完成了它的所有任务，接下来的任务交给了其它地方处理。</p><p>分块有什么好处？</p><p>浏览器会优先处理视口区域内的块内容，让我们可以见到的区域渲染的优先等级提高，让我们的可是范围内的内容更快的完成渲染。</p><p>该过程结束后每一层中都有了区域的划分</p><h3 id="_7-光栅化" tabindex="-1"><a class="header-anchor" href="#_7-光栅化" aria-hidden="true">#</a> 7.光栅化</h3><p><strong>该过程中，浏览器的合成线程将每个块信息交给GPU进程处理</strong></p><p>该过程的结果就是得到一块块的位图信息（像素信息）</p><h3 id="_8-画" tabindex="-1"><a class="header-anchor" href="#_8-画" aria-hidden="true">#</a> 8.画</h3><p>合成线程得到每一块位图信息后，会根据每一块位图的信息生成指引信息，指引信息标识出每个位图应该画到屏幕的哪个位置（其中考虑了节点元素的缩放、旋转等变形）</p><p>正因为变形等操作发生在画的阶段，不发生在渲染主线程，而是发生在合成线程中，所以这就是transform的效率高的本质原因。</p><p>最终合成线程把指引信息交给GPU进程，由GPU进程调用GPU硬件，完成图形的绘制，最终成像。</p>`,51),i=[s];function d(t,l){return e(),n("div",null,i)}const h=a(p,[["render",d],["__file","render-flow.html.vue"]]);export{h as default};
