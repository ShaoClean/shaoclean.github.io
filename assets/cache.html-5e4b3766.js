import{_ as n,a0 as s,a1 as a,a4 as p}from"./framework-16947f8e.js";const e={},t=p(`<h1 id="http-缓存" tabindex="-1"><a class="header-anchor" href="#http-缓存" aria-hidden="true">#</a> HTTP 缓存</h1><p>前几天在想如何解决图片加载的问题时，想到了用 redis 区实现。大致的思路是就是将已经请求过的图片资源存放在 redis 中。但是后面又想了一下，这样会很浪费资源。不仅本地存了原始的图片文件，数据库中存了图片对应的 base64，如果还往 redis 中再存一份的话，会非常的浪费空间资源。</p><p>今天在思考的时候，突然想到可以利用浏览器的缓存来实现。于是又去看了一下缓存相关的知识，也算是再复习一遍了。</p><p>缓存相关的主要知识慢慢的补充，这里先讲一下我是如何解决的。</p><h2 id="例子" tabindex="-1"><a class="header-anchor" href="#例子" aria-hidden="true">#</a> 例子</h2><p>在后端相关的请求借口设置相应头，拿 nest 举例：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code> <span class="token doc-comment comment">/**
 * 获取单个图片信息
 */</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Header</span></span><span class="token punctuation">(</span><span class="token string">&#39;Cache-Control&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;max-age=1000&#39;</span><span class="token punctuation">)</span>
<span class="token function">findOne</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Query</span></span><span class="token punctuation">(</span><span class="token string">&#39;id&#39;</span><span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>imageService<span class="token punctuation">.</span><span class="token function">findOne</span><span class="token punctuation">(</span><span class="token operator">+</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的请求接口为：<code>http://localhost:3000/image</code></p><p>没错这里用到的是<code>强缓存</code>，前端在第一次请求这个接口的时候，该接口会正常的响应。</p><p>由于在响应头里面设置了<code>Cache-Control</code>，并且过期时间为<code>1000s(max-age=1000)</code>。</p><p>比如我现在请求了一个 id 为 16 的信息，那么对应的请求 url 就是:<code>http://localhost:3000/image?id=16</code></p><p>所以在接下来的 1000 秒内，对于请求同一个资源，也就是通过该浏览器请求相同的 url 路径时，该接口都不会被请求到。也就是所谓的命中了强缓存，直接走了浏览器的本地缓存。</p><p>除非使用强制刷新或者过了 1000s，才不会走强缓存。</p><p>** 需要注意的是： **</p><ol><li><p>除了 get 请求，其它的请求方式不能被缓存</p></li><li><p>http 缓存有大小限制</p></li></ol><p>就比如这个例子:</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token doc-comment comment">/**
 * 获取全部信息
 */</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">&#39;/all&#39;</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Header</span></span><span class="token punctuation">(</span><span class="token string">&#39;Cache-Control&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;max-age=20000&#39;</span><span class="token punctuation">)</span>
<span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;get!&#39;</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>imageService<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请求这个接口会返回所有的图片数据（70M），但是我发现不管我如何请求，都不会走强缓存，虽然返回的都是状态码都是 200。</p><p>后面百度+尝试发现：chrome 内核的浏览器（我用的是 Arc 浏览器）HTTP 缓存的上限是 40M。</p><p>小于这个值都能成功的命中强缓存。</p><p>好了，知道了这些，解决公司的那个问题基本的思路能确定了。</p><ol><li><p>前端请求数据的方式改为 get</p></li><li><p>后端相关的接口设置响应头，启用强缓存</p></li><li><p>每次重新开启的增强预览请求的路径中都带上本次增强的唯一 uuid，避免前后两次的冲突</p></li><li><p>确定一个合理的缓存过期时间</p></li></ol><p>面对上面的第四点，引发出一个新的问题，就是如何解决大量缓存的堆积问题</p><h1 id="强缓存" tabindex="-1"><a class="header-anchor" href="#强缓存" aria-hidden="true">#</a> 强缓存</h1>`,24),c=[t];function o(i,l){return s(),a("div",null,c)}const r=n(e,[["render",o],["__file","cache.html.vue"]]);export{r as default};
